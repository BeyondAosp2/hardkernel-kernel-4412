# Copyright:
# ----------------------------------------------------------------------------
# This confidential and proprietary software may be used only as authorized 
# by a licensing agreement from ARM Limited.
#      (C) COPYRIGHT 2010-2011 ARM Limited, ALL RIGHTS RESERVED
# The entire notice above must be reproduced on all authorized copies and 
# copies may only be made to the extent permitted by a licensing agreement
# from ARM Limited.
# ----------------------------------------------------------------------------
#

import os
import sys
Import('env')

scheduling_policy = 'rr'

if env['os'] == 'linux' or env['os'] == 'android':
	if env['hw'] == '2':
		if env['v'] != '1':
			env['MAKECOMSTR'] = '[MAKE] ${SOURCE.dir}'
		
		# Source files required for kbase.
		kbase_src = [Glob('#kbase/src/common/*.c'), Glob('#kbase/src/linux/*.c'), Glob('#kbase/src/common/*.h'), Glob('#kbase/src/linux/*.h')]
	
		# Note: cleaning via the Linux kernel build system does not yet work
		if env.GetOption('clean') :
			makeAction=Action("cd ${SOURCE.dir}/.. && make clean", '$MAKECOMSTR')
		else:
			if env['os'] == 'android':
				env['android'] = 1
			else:
				env['android'] = 0


			makeAction=Action("cd ${SOURCE.dir}/.. && make PLATFORM=${platform} MALI_HW_TYPE=${hw} MALI_HW_VERSION=${hwver} MALI_KBASE_USE_UMP=1 MALI_DEBUG=${debug} MALI_ANDROID=${android} MALI_BASE_TRACK_MEMLEAK=${base_qa} MALI_KBASE_SCHEDULING_POLICY=%s && cp mali_kbase.ko $STATIC_LIB_PATH/mali_kbase.ko" % (scheduling_policy), '$MAKECOMSTR')
			
		cmd = env.Command('$STATIC_LIB_PATH/mali_kbase.ko', kbase_src, [makeAction])

		env.Depends('$STATIC_LIB_PATH/mali_kbase.ko', '$STATIC_LIB_PATH/libosk.a')
		# need Module.symvers from ukk.kko and ump.ko builds
		env.Depends('$STATIC_LIB_PATH/mali_kbase.ko', '$STATIC_LIB_PATH/ukk.ko')
		env.Depends('$STATIC_LIB_PATH/mali_kbase.ko', '$STATIC_LIB_PATH/ump.ko')

		# Until we fathom out how the invoke the Linux build system to clean, we can use Clean
		# to remove generated files.
		patterns = ['*.mod.c', '*.o', '*.ko', '*.a', '.*.cmd', 'modules.order', '.tmp_versions', 'Module.symvers']

		for p in patterns:
			Clean(cmd, Glob('#kbase/src/%s' % p))
			Clean(cmd, Glob('#kbase/src/linux/%s' % p))
			Clean(cmd, Glob('#kbase/src/common/%s' % p))

		env.ProgTarget('kbase', cmd)

		env.AppendUnique(BASE=['cutils_list'])
	else:
		common_source = [
			'common/mali_kbase_mem.c',
			'common/mali_kbase_mmu.c',
			'common/mali_kbase_jd.c',
			'common/mali_kbase_jm.c',
			'common/mali_kbase_js.c',
			'common/mali_kbase_js_policy_%s.c' % (scheduling_policy),
			'common/mali_kbase_pm.c',
			'common/mali_kbase_event.c',
			'common/mali_kbase_context.c',
			'common/mali_kbase_pm.c',
			'common/mali_kbase_pm_driver.c',
			'common/mali_kbase_pm_always_on.c',
			'common/mali_kbase_pm_demand.c',
			'common/mali_kbase_device.c',
			'userspace/mali_kbase_core.c',
			'userspace/mali_kbase_model.c',
			'userspace/mali_kbase_mem_userspace.c'
			]

		os_source = []

		if env['os'] in  ['linux']:
			pass
		else:
			sys.stderr.write("*** Unsupported OS: %s\n" % env['os'])
			Exit(1)
		
		env.Append( CPPDEFINES = {'MALI_KBASE_USE_UMP' : 0} )
		env.Append( CPPDEFINES = {'MALI_KBASE_USERSPACE' : 1} )

		if env['hw'] == '0':
			hwsim_source = ['userspace/mali_kbase_model_dummy.c']
			env.AppendUnique(BASE=['cutils_list', 'kbase'])
		else:
			# Unpack and extract the model - will only work on x86 Linux
			if env['arch'] == 'x86_64':
				hostbits = '64'
			else:
				hostbits = '32'

			# Create a builder to handle extracting the model binary from the tarball. Using a builder,
			# we can define a custom COMSTR to give less verbose output if requested.
			extract = Action('tar xzf $SOURCE --strip-components 4 Rexported/lib/x86_rhe5_%s/%s/libMidgardModel.so -O > $TARGET' % (hostbits, env['model']), "$EXTRACTCOMSTR")
			extract_builder = Builder(action = extract)
			env.Append(BUILDERS = {'Extract' : extract_builder})
			if not int(env['v']):
				env.Append(EXTRACTCOMSTR = '[EXTRACT] $TARGET')

			# Any builds dependent on the target "model" will cause the binary to be extracted
			# Note that to maintain compatability with existing build files that expect to link against
			# the static version, we extract to $STATIC_LIB_PATH too.
			model = env.Extract('$STATIC_LIB_PATH/libMidgardModel.so','#model/model.tgz')
			model_dlib = env.Extract('$SHARED_LIB_PATH/libMidgardModel.so','#model/model.tgz')
			env.Depends(model, model_dlib)

			# Create an action that can be used as a post-action, to install the model whenever it is unpacked,
			# provding that the command-line option "libs_install" has been set. We also add a Clean method
			# to delete the installed model when the extracted model is cleaned.
			if env.has_key('libs_install'):
				a = Action("mkdir -p {libs}; cp $STATIC_LIB_PATH/libMidgardModel.so {libs}".format(libs=env['libs_install']), "$COPYCOMSTR")
				if not int(env['v']):
					env.Append(COPYCOMSTR = '[COPY] $TARGET')
				env.AddPostAction(model, a)
				env.Clean(model, os.path.join(env['libs_install'], "libMidgardModel.so"))


			hwsim_source = []
			env.AppendUnique(
					BASE=['cutils_list', 'kbase', 'MidgardModel', 'stdc++']
					)
			env.Alias('kbase', model)

		libs=env.StaticLibrary( '$STATIC_LIB_PATH/kbase', [common_source, os_source, hwsim_source])
		env.LibTarget('kbase', libs)





